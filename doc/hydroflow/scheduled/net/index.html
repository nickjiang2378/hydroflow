<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contiains networking code."><title>hydroflow::scheduled::net - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="hydroflow" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (d7f6ebace 2024-06-16)" data-channel="nightly" data-search-js="search-0fe7219eb170c82e.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../hydroflow/index.html">hydroflow</a><span class="version">0.9.0</span></h2></div><h2 class="location"><a href="#">Module net</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li></ul></section><h2><a href="../index.html">In hydroflow::scheduled</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">hydroflow</a>::<wbr><a href="../index.html">scheduled</a>::<wbr><a class="mod" href="#">net</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/hydroflow/scheduled/net/mod.rs.html#1-165">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contiains networking code.</p>
<h3 id="how-tokio-interacts-with-hydroflow-mingwei-2021-12-07"><a class="doc-anchor" href="#how-tokio-interacts-with-hydroflow-mingwei-2021-12-07">§</a>How Tokio interacts with Hydroflow (Mingwei 2021-12-07)</h3>
<p><a href="https://tokio.rs/">Tokio</a> is a Rust async runtime. In Rust’s async/await
system, <code>Future</code>s must be spawned or sent to an async runtime in order to
run. Tokio is the most popular provider of one of these runtimes, with
<a href="https://async.rs/">async-std</a> (mirrors std lib) and <a href="https://github.com/smol-rs/smol">smol</a>
(minimal runtime) as commonly used alternatives.</p>
<p>Fundamentally, an async runtime’s job is to poll futures (read: run tasks)
when they are ready to make progress. However async runtimes also provide a
<code>Future</code>s abstraction for async events such as timers, network IO, and
filesystem IO. To do this, <a href="https://tokio.rs/">Tokio</a> uses <a href="https://github.com/tokio-rs/mio">Mio</a>
which is a low-level non-blocking API for IO event notification/polling.
A user of Mio can write an event loop, i.e. something like: wait for
events, run computations responding to those events, repeat. Tokio provides
the higher-level async/await slash <code>Future</code> abstraction on top of Mio, as
well as the runtime to execute those <code>Future</code>s. Essentially, the Tokio
async runtime essentially replaces the low-level event loop a user might
handwrite when using Mio.</p>
<p>For context, both Mio and Tokio provide socket/UDP/TCP-level network
abstractions, which is probably the right layer for us. There are also
libraries built on top of Tokio providing nice server/client HTTP APIs
like <a href="https://hyper.rs/">Hyper</a>.</p>
<p>The Hydroflow scheduled layer scheduler is essentially the same as a simple
event loop: it runs subgraphs when they have data. We have also let it
respond to external asynchonous events by providing a threadsafe channel
through which subgraphs can be externally scheduled.</p>
<p>In order to add networking to Hydroflow, in our current implementation we
use Tokio and have a compatibility mechanism for working with <code>Future</code>s.
A <code>Future</code> provides a <code>Waker</code> mechanism to notify when it had work to do,
so we have hooked these Wakers up with Hydroflow’s threadsafe external
scheduling channel. This essentially turns Hydroflow into a simple async
runtime.</p>
<p>However in some situations, we still need to run futures outside of
Hydroflow’s basic runtime. It’s not a goal for Hydroflow to provide all
the features of a full runtime like Tokio. Currently for this situation we
run Hydroflow as a task (<code>Future</code>) within the Tokio runtime. In Hydroflow’s
event loop we do all available work, then rather than block and wait for
external events to schedule more tasks, we temporarily yield back to the
Tokio runtime. Tokio will then respond to any outstanding events it has
before once again running the Hydroflow scheduler task.</p>
<p>This works perfectly well but maybe isn’t the best solution long-term.
In the future we may want to remove the extra Tokio runtime layer and
interface with Mio directly. In this case we would have to do our own
socket-style polling within the Hydroflow scheduler’s event loop, which
would require some extra work and thought. But for now interfacing with
Tokio works and I don’t think the overhead of the extra runtime loop is
significant.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="network_vertex/index.html" title="mod hydroflow::scheduled::net::network_vertex">network_vertex</a></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct hydroflow::scheduled::net::Message">Message</a></div></li></ul></section></div></main></body></html>