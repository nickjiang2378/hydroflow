<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/hydroflow/hydroflow/target/debug/build/hydroflow_plus-49eba6b6eb5f9125/out/lib_pub.rs`."><title>lib_pub.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="hydroflow_plus" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (d7f6ebace 2024-06-16)" data-channel="nightly" data-search-js="search-0fe7219eb170c82e.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre></div><pre class="rust"><code><span class="kw">pub use </span>std :: collections :: BTreeMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow :: scheduled :: context :: Context ; <span class="kw">pub use </span>hydroflow :: scheduled :: graph :: Hydroflow ; <span class="kw">pub use </span>hydroflow :: * ; <span class="kw">pub use </span>lang :: graph :: { partition_graph , HydroflowGraph } ; <span class="kw">pub use </span>proc_macro2 :: TokenStream ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>stageleft :: runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>runtime_support { <span class="kw">pub use </span>bincode ; } <span class="kw">pub mod </span>stream { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: hash :: Hash ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow :: bytes :: Bytes ; <span class="kw">pub use </span>hydroflow :: futures :: Sink ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>serde :: de :: DeserializeOwned ; <span class="kw">pub use </span>serde :: Serialize ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: builder :: { ClusterIds , FlowLeaves } ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleComplete } ; <span class="kw">pub use crate </span>:: ir :: { DebugInstantiate , HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: location :: { CanSend , Location , LocationId } ; <span class="kw">pub use crate </span>:: { Cluster , Optional , Singleton } ; <span class="kw">pub use crate </span>:: stream :: Unbounded ; <span class="kw">pub use crate </span>:: stream :: Bounded ; <span class="kw">pub use crate </span>:: stream :: NoTick ; <span class="kw">pub use crate </span>:: stream :: Tick ; <span class="kw">pub use crate </span>:: stream :: Stream ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleComplete &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleCollection &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , l : LocationId) -&gt; <span class="self">Self </span>{ Stream :: new (l , ir_leaves , HfPlusNode :: CycleSource { ident , location_kind : l , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleComplete &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleCollection &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , l : LocationId) -&gt; <span class="self">Self </span>{ Stream :: new (l , ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>{ Stream { location_kind , ir_leaves , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &gt; Clone <span class="kw">for </span>Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : Rc :: new (RefCell :: new (orig_ir_node)) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Stream { location_kind : <span class="self">self </span>. location_kind , ir_leaves : <span class="self">self </span>. ir_leaves . clone () , ir_node : HfPlusNode :: Tee { inner : inner . clone () , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Map { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FlatMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Filter { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FilterMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; <span class="lifetime">'a </span>, O , Bounded , C , N &gt; &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (T , O) , W , C , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; <span class="lifetime">'a </span>, O , Bounded , C , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>cross_product &lt; O &gt; (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, O , W , C , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (T , O) , W , C , N &gt; <span class="kw">where </span>T : Clone , O : Clone , { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_product must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossProduct (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>dest_sink &lt; S : Unpin + Sink &lt; T &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, sink : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, S &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: DestSink { sink : sink . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Clone , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Inspect { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>first (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner () ,) } # [doc = <span class="string">" Allow this stream through if the other stream has elements, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } # [doc = <span class="string">" Allow this stream through if the other stream is empty, otherwise the output is empty."</span>] <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>enumerate (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, (usize , T) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Enumerate (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Singleton &lt; <span class="lifetime">'a </span>, A , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Fold { init : init . splice () . into () , acc : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Reduce { f : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>sort (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Ord , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Sort (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>count (<span class="self">self</span>) -&gt; Singleton &lt; <span class="lifetime">'a </span>, usize , Bounded , Tick , N &gt; { <span class="self">self </span>. fold (q ! (|| <span class="number">0usize</span>) , q ! (| count , <span class="kw">_ </span>| * count += <span class="number">1</span>)) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>unique (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Eq + Hash , { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Unique (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">pub fn </span>tick_batch (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>tick_prefix (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; <span class="kw">where </span>T : Clone , { <span class="self">self </span>. tick_batch () . persist () } <span class="kw">pub fn </span>inspect &lt; F : Fn (&amp; T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Inspect { f : f . splice () . into () , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">pub fn </span>for_each &lt; F : Fn (T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt;) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: ForEach { input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , f : f . splice () . into () , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>interval = duration . splice () ; <span class="kw">let </span>samples = Stream :: &lt; <span class="lifetime">'a </span>, hydroflow :: tokio :: time :: Instant , Bounded , Tick , N &gt; :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : <span class="self">self </span>. location_kind , } ,) ; <span class="self">self </span>. tick_batch () . continue_if (samples . first ()) . all_ticks () } <span class="kw">pub fn </span>fold &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , T) &gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Singleton &lt; <span class="lifetime">'a </span>, A , Unbounded , NoTick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Fold { init : init . splice () . into () , acc : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , })) ,) } <span class="kw">pub fn </span>reduce &lt; F : Fn (&amp; <span class="kw-2">mut </span>T , T) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Reduce { f : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , C , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , C , N &gt; { <span class="kw">pub fn </span>filter_not_in (<span class="self">self </span>, other : Stream &lt; <span class="lifetime">'a </span>, T , Bounded , C , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , C , N &gt; <span class="kw">where </span>T : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Difference (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, &amp; T , W , C , N &gt; { <span class="kw">pub fn </span>cloned (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="self">self </span>. map (q ! (| d | d . clone ())) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K , V1 , W , C , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , C , N &gt; { <span class="kw">pub fn </span>join &lt; W2 , V2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, (K , V2) , W2 , C , N &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , (V1 , V2)) , W , C , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != n . location_kind { panic ! (<span class="string">"join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Join (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>anti_join &lt; W2 &gt; (<span class="self">self </span>, n : Stream &lt; <span class="lifetime">'a </span>, K , W2 , C , N &gt;) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V1) , W , C , N &gt; <span class="kw">where </span>K : Eq + Hash , { <span class="kw">if </span><span class="self">self </span>. location_kind != n . location_kind { panic ! (<span class="string">"anti_join must be called on streams on the same node"</span>) ; } Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: AntiJoin (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (n . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, K : Eq + Hash , V , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>fold_keyed &lt; A , I : Fn () -&gt; A + <span class="lifetime">'a </span>, F : Fn (&amp; <span class="kw-2">mut </span>A , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, init : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, I &gt; , comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , A) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FoldKeyed { init : init . splice () . into () , acc : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>reduce_keyed &lt; F : Fn (&amp; <span class="kw-2">mut </span>V , V) + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, comb : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, (K , V) , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: ReduceKeyed { f : comb . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } <span class="kw">pub fn </span>get_this_crate () -&gt; TokenStream { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , Span :: call_site ()) ; quote ! { # ident } } } } <span class="kw">pub fn </span>serialize_bincode &lt; T : Serialize &gt; (is_demux : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>is_demux { parse_quote ! { map (| (id , data) | { (id , # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| data | { # root :: runtime_support :: bincode :: serialize ::&lt;# t_type &gt; (&amp; data) . unwrap () . into () }) } } } <span class="kw">pub fn </span>deserialize_bincode &lt; T : DeserializeOwned &gt; (tagged : bool) -&gt; Pipeline { <span class="kw">let </span>root = get_this_crate () ; <span class="kw">let </span>t_type : syn :: Type = stageleft :: quote_type :: &lt; T &gt; () ; <span class="kw">if </span>tagged { parse_quote ! { map (| res | { <span class="kw">let </span>(id , b) = res . unwrap () ; (id , # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; b) . unwrap ()) }) } } <span class="kw">else </span>{ parse_quote ! { map (| res | { # root :: runtime_support :: bincode :: deserialize ::&lt;# t_type &gt; (&amp; res . unwrap ()) . unwrap () }) } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; Stream &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">pub fn </span>send_bincode &lt; N2 : Location , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; CoreType &gt; , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; N2 , In &lt; CoreType &gt; = T &gt; , CoreType : Serialize + DeserializeOwned , { <span class="kw">let </span>serialize_pipeline = <span class="prelude-val">Some </span>(serialize_bincode :: &lt; CoreType &gt; (N :: is_demux ())) ; <span class="kw">let </span>deserialize_pipeline = <span class="prelude-val">Some </span>(deserialize_bincode :: &lt; CoreType &gt; (N :: is_tagged ())) ; Stream :: new (other . id () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , to_location : other . id () , serialize_pipeline , instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bytes &lt; N2 : Location &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; N2 , In &lt; Bytes &gt; = T &gt; , { Stream :: new (other . id () , <span class="self">self </span>. ir_leaves , HfPlusNode :: Network { from_location : <span class="self">self </span>. location_kind , to_location : other . id () , serialize_pipeline : <span class="prelude-val">None </span>, instantiate_fn : DebugInstantiate :: Building () , deserialize_pipeline : <span class="kw">if </span>N :: is_tagged () { <span class="prelude-val">Some </span>(parse_quote ! (map (| (id , b) | (id , b . unwrap () . freeze ())))) } <span class="kw">else </span>{ <span class="prelude-val">Some </span>(parse_quote ! (map (| b | b . unwrap () . freeze ()))) } , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>send_bincode_interleaved &lt; N2 : Location , Tag , CoreType &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, CoreType , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; N2 , In &lt; CoreType &gt; = T , Out &lt; CoreType &gt; = (Tag , CoreType) &gt; , CoreType : Serialize + DeserializeOwned , { <span class="self">self </span>. send_bincode :: &lt; N2 , CoreType &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>send_bytes_interleaved &lt; N2 : Location , Tag &gt; (<span class="self">self </span>, other : &amp; N2 ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Unbounded , NoTick , N2 &gt; <span class="kw">where </span>N : CanSend &lt; N2 , In &lt; Bytes &gt; = T , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; , { <span class="self">self </span>. send_bytes :: &lt; N2 &gt; (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bincode &lt; C2 &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; C2 &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; T &gt; , Unbounded , NoTick , Cluster &lt; C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; Cluster &lt; C2 &gt; , In &lt; T &gt; = (u32 , T) &gt; , T : Clone + Serialize + DeserializeOwned , { <span class="kw">let </span>ids = ClusterIds :: &lt; <span class="lifetime">'a </span>&gt; { id : other . id , _phantom : PhantomData , } ; <span class="self">self </span>. flat_map (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bincode (other) } <span class="kw">pub fn </span>broadcast_bincode_interleaved &lt; C2 , Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; C2 &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , Cluster &lt; C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; Cluster &lt; C2 &gt; , In &lt; T &gt; = (u32 , T) , Out &lt; T &gt; = (Tag , T) &gt; + <span class="lifetime">'a </span>, T : Clone + Serialize + DeserializeOwned , { <span class="self">self </span>. broadcast_bincode (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } <span class="kw">pub fn </span>broadcast_bytes &lt; C2 &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; C2 &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, N :: Out &lt; Bytes &gt; , Unbounded , NoTick , Cluster &lt; C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; Cluster &lt; C2 &gt; , In &lt; Bytes &gt; = (u32 , T) &gt; + <span class="lifetime">'a </span>, T : Clone , { <span class="kw">let </span>ids = ClusterIds :: &lt; <span class="lifetime">'a </span>&gt; { id : other . id , _phantom : PhantomData , } ; <span class="self">self </span>. flat_map (q ! (| b | ids . iter () . map (<span class="kw">move </span>| id | (:: std :: clone :: Clone :: clone (id) , :: std :: clone :: Clone :: clone (&amp; b))))) . send_bytes (other) } <span class="kw">pub fn </span>broadcast_bytes_interleaved &lt; C2 , Tag &gt; (<span class="self">self </span>, other : &amp; Cluster &lt; C2 &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, Bytes , Unbounded , NoTick , Cluster &lt; C2 &gt; &gt; <span class="kw">where </span>N : CanSend &lt; Cluster &lt; C2 &gt; , In &lt; Bytes &gt; = (u32 , T) , Out &lt; Bytes &gt; = (Tag , Bytes) &gt; + <span class="lifetime">'a </span>, T : Clone , { <span class="self">self </span>. broadcast_bytes (other) . map (q ! (| (<span class="kw">_ </span>, b) | b)) } } } <span class="kw">pub use </span>stream :: { Bounded , NoTick , Stream , Tick , Unbounded } ; <span class="kw">pub mod </span>singleton { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>stageleft :: { q , IntoQuotedMut , Quoted } ; <span class="kw">pub use crate </span>:: builder :: FlowLeaves ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleCollectionWithInitial , CycleComplete } ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: stream :: { Bounded , NoTick , Tick , Unbounded } ; <span class="kw">pub use crate </span>:: Stream ; <span class="kw">pub use crate </span>:: singleton :: CrossResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &gt; CrossResult &lt; <span class="lifetime">'a </span>, Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; &gt; <span class="kw">for </span>Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">type </span>Out = Singleton &lt; <span class="lifetime">'a </span>, (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>:: Out { Singleton :: new (location_kind , ir_leaves , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &gt; CrossResult &lt; <span class="lifetime">'a </span>, Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; &gt; <span class="kw">for </span>Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; <span class="lifetime">'a </span>, (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , ir_leaves , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &gt; CrossResult &lt; <span class="lifetime">'a </span>, Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; <span class="lifetime">'a </span>, (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , ir_leaves , ir_node) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , U : Clone , W , C , N : Location &gt; CrossResult &lt; <span class="lifetime">'a </span>, Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">type </span>Out = Optional &lt; <span class="lifetime">'a </span>, (T , U) , W , C , N &gt; ; <span class="kw">fn </span>other_location (other : &amp; Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; LocationId { other . location_kind } <span class="kw">fn </span>other_ir_node (other : Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt;) -&gt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; { other . ir_node . into_inner () } <span class="kw">fn </span>make (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>:: Out { Optional :: new (location_kind , ir_leaves , ir_node) } } <span class="kw">pub use crate </span>:: singleton :: Singleton ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>{ Singleton { location_kind , ir_leaves , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; CycleComplete &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; CycleCollectionWithInitial &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , initial : <span class="self">Self </span>, l : LocationId ,) -&gt; <span class="self">Self </span>{ Singleton :: new (l , ir_leaves , HfPlusNode :: Union (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , }) , initial . ir_node . into_inner () . into () ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &gt; Clone <span class="kw">for </span>Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : Rc :: new (RefCell :: new (orig_ir_node)) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Singleton { location_kind : <span class="self">self </span>. location_kind , ir_leaves : <span class="self">self </span>. ir_leaves . clone () , ir_node : HfPlusNode :: Tee { inner : inner . clone () , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Singleton &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Map { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FlatMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Filter { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FilterMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; Other &gt; (<span class="self">self </span>, other : Other) -&gt; &lt; <span class="self">Self </span><span class="kw">as </span>CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; &gt; :: Out <span class="kw">where </span><span class="self">Self </span>: CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; , { <span class="kw">if </span><span class="self">self </span>. location_kind != <span class="self">Self </span>:: other_location (&amp; other) { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">Self </span>:: make (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (<span class="self">Self </span>:: other_ir_node (other)) ,) ,) } <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , B , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , B , NoTick , N &gt; { <span class="kw">pub fn </span>latest_tick (<span class="self">self</span>) -&gt; Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Singleton :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Singleton &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; Other &gt; (<span class="self">self </span>, other : Other) -&gt; &lt; <span class="self">Self </span><span class="kw">as </span>CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; &gt; :: Out <span class="kw">where </span><span class="self">Self </span>: CrossResult &lt; <span class="lifetime">'a </span>, Other &gt; , { <span class="kw">if </span><span class="self">self </span>. location_kind != <span class="self">Self </span>:: other_location (&amp; other) { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">Self </span>:: make (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CrossSingleton (Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">Self </span>:: other_ir_node (other)))) ,))) ,) } } <span class="kw">pub use crate </span>:: singleton :: Optional ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub </span>(<span class="kw">crate</span>) <span class="kw">fn </span>new (location_kind : LocationId , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , ir_node : HfPlusNode &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; <span class="self">Self </span>{ Optional { location_kind , ir_leaves , ir_node : RefCell :: new (ir_node) , _phantom : PhantomData , } } <span class="kw">pub fn </span>some (singleton : Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt;) -&gt; <span class="self">Self </span>{ Optional :: new (singleton . location_kind , singleton . ir_leaves , singleton . ir_node . into_inner () ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleComplete &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , Tick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleCollection &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , Tick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , l : LocationId) -&gt; <span class="self">Self </span>{ Optional :: new (l , ir_leaves , HfPlusNode :: CycleSource { ident , location_kind : l , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleComplete &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">fn </span>complete (<span class="self">self </span>, ident : syn :: Ident) { <span class="self">self </span>. ir_leaves . borrow_mut () . as_mut () . expect (<span class="string">"Attempted to add a leaf to a flow that has already been finalized. No leaves can be added after the flow has been compiled."</span>) . push (HfPlusLeaf :: CycleSink { ident , location_kind : <span class="self">self </span>. location_kind , input : Box :: new (HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ()))) , }) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , N : Location &gt; CycleCollection &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , NoTick , N &gt; { <span class="kw">type </span>Location = N ; <span class="kw">fn </span>create_source (ident : syn :: Ident , ir_leaves : FlowLeaves &lt; <span class="lifetime">'a </span>&gt; , l : LocationId) -&gt; <span class="self">Self </span>{ Optional :: new (l , ir_leaves , HfPlusNode :: Persist (Box :: new (HfPlusNode :: CycleSource { ident , location_kind : l , })) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; From &lt; Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; &gt; <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">fn </span>from (singleton : Singleton &lt; <span class="lifetime">'a </span>, T , W , C , N &gt;) -&gt; <span class="self">Self </span>{ Optional :: some (singleton) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Clone , W , C , N : Location &gt; Clone <span class="kw">for </span>Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ <span class="kw">if </span>! matches ! (<span class="self">self </span>. ir_node . borrow () . deref () , HfPlusNode :: Tee { .. }) { <span class="kw">let </span>orig_ir_node = <span class="self">self </span>. ir_node . replace (HfPlusNode :: Placeholder) ; * <span class="self">self </span>. ir_node . borrow_mut () = HfPlusNode :: Tee { inner : Rc :: new (RefCell :: new (orig_ir_node)) , } ; } <span class="kw">if let </span>HfPlusNode :: Tee { inner } = <span class="self">self </span>. ir_node . borrow () . deref () { Optional { location_kind : <span class="self">self </span>. location_kind , ir_leaves : <span class="self">self </span>. ir_leaves . clone () , ir_node : HfPlusNode :: Tee { inner : inner . clone () , } . into () , _phantom : PhantomData , } } <span class="kw">else </span>{ unreachable ! () } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , W , C , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { <span class="kw">pub fn </span>map &lt; U , F : Fn (T) -&gt; U + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Map { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>flat_map &lt; U , I : IntoIterator &lt; Item = U &gt; , F : Fn (T) -&gt; I + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FlatMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter &lt; F : Fn (&amp; T) -&gt; bool + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Filter { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } <span class="kw">pub fn </span>filter_map &lt; U , F : Fn (T) -&gt; <span class="prelude-ty">Option </span>&lt; U &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, f : <span class="kw">impl </span>IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, U , W , C , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: FilterMap { f : f . splice () . into () , input : Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , } ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>into_stream (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , <span class="self">self </span>. ir_node . into_inner () ,) } <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; <span class="lifetime">'a </span>, O , Bounded , Tick , N &gt; &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, (T , O) , Bounded , Tick , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; <span class="lifetime">'a </span>, O , Bounded , Tick , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: CrossSingleton (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } <span class="kw">pub fn </span>continue_if &lt; U &gt; (<span class="self">self </span>, signal : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. cross_singleton (signal . map (q ! (| _u | ()))) . map (q ! (| (d , _signal) | d)) } <span class="kw">pub fn </span>continue_unless &lt; U &gt; (<span class="self">self </span>, other : Optional &lt; <span class="lifetime">'a </span>, U , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="self">self </span>. continue_if (other . into_stream () . count () . filter (q ! (| c | * c == <span class="number">0</span>))) } <span class="kw">pub fn </span>union (<span class="self">self </span>, other : Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"union must be called on streams on the same node"</span>) ; } Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Union (Box :: new (<span class="self">self </span>. ir_node . into_inner ()) , Box :: new (other . ir_node . into_inner ()) ,) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { <span class="kw">pub fn </span>all_ticks (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>latest (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>defer_tick (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: DeferTick (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>persist (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Stream :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Persist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>delta (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Delta (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , B , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , B , NoTick , N &gt; { <span class="kw">pub fn </span>latest_tick (<span class="self">self</span>) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , N &gt; { Optional :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves , HfPlusNode :: Unpersist (Box :: new (<span class="self">self </span>. ir_node . into_inner ())) ,) } <span class="kw">pub fn </span>tick_samples (<span class="self">self</span>) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="self">self </span>. latest_tick () . all_ticks () } <span class="kw">pub fn </span>sample_every (<span class="self">self </span>, duration : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, std :: time :: Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="kw">let </span>interval = duration . splice () ; <span class="kw">let </span>samples = Stream :: &lt; <span class="lifetime">'a </span>, hydroflow :: tokio :: time :: Instant , Bounded , Tick , N &gt; :: new (<span class="self">self </span>. location_kind , <span class="self">self </span>. ir_leaves . clone () , HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : <span class="self">self </span>. location_kind , } ,) ; <span class="self">self </span>. latest_tick () . continue_if (samples . first ()) . latest () . tick_samples () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T , N : Location &gt; Optional &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , N &gt; { <span class="kw">pub fn </span>cross_singleton &lt; O &gt; (<span class="self">self </span>, other : <span class="kw">impl </span>Into &lt; Optional &lt; <span class="lifetime">'a </span>, O , Unbounded , NoTick , N &gt; &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, (T , O) , Unbounded , NoTick , N &gt; <span class="kw">where </span>O : Clone , { <span class="kw">let </span>other : Optional &lt; <span class="lifetime">'a </span>, O , Unbounded , NoTick , N &gt; = other . into () ; <span class="kw">if </span><span class="self">self </span>. location_kind != other . location_kind { panic ! (<span class="string">"cross_singleton must be called on streams on the same node"</span>) ; } <span class="self">self </span>. latest_tick () . cross_singleton (other . latest_tick ()) . latest () } } } <span class="kw">pub use </span>singleton :: { Optional , Singleton } ; <span class="kw">pub mod </span>location { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use crate </span>:: location :: LocationId ; <span class="kw">pub use crate </span>:: location :: Location ; <span class="kw">pub use crate </span>:: location :: Process ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P &gt; Clone <span class="kw">for </span>Process &lt; P &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Process { id : <span class="self">self </span>. id , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P &gt; Location <span class="kw">for </span>Process &lt; P &gt; { <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Process (<span class="self">self </span>. id) } } <span class="kw">pub use crate </span>:: location :: Cluster ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Clone <span class="kw">for </span>Cluster &lt; C &gt; { <span class="kw">fn </span>clone (&amp; <span class="self">self</span>) -&gt; <span class="self">Self </span>{ Cluster { id : <span class="self">self </span>. id , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C &gt; Location <span class="kw">for </span>Cluster &lt; C &gt; { <span class="kw">fn </span>id (&amp; <span class="self">self</span>) -&gt; LocationId { LocationId :: Cluster (<span class="self">self </span>. id) } } <span class="kw">pub use crate </span>:: location :: CanSend ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P1 , P2 &gt; CanSend &lt; Process &lt; P2 &gt; &gt; <span class="kw">for </span>Process &lt; P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; P1 , C2 &gt; CanSend &lt; Cluster &lt; C2 &gt; &gt; <span class="kw">for </span>Process &lt; P1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (u32 , T) ; <span class="kw">type </span>Out &lt; T &gt; = T ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">false </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C1 , P2 &gt; CanSend &lt; Process &lt; P2 &gt; &gt; <span class="kw">for </span>Cluster &lt; C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = T ; <span class="kw">type </span>Out &lt; T &gt; = (u32 , T) ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">false </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; C1 , C2 &gt; CanSend &lt; Cluster &lt; C2 &gt; &gt; <span class="kw">for </span>Cluster &lt; C1 &gt; { <span class="kw">type </span>In &lt; T &gt; = (u32 , T) ; <span class="kw">type </span>Out &lt; T &gt; = (u32 , T) ; <span class="kw">fn </span>is_demux () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>is_tagged () -&gt; bool { <span class="bool-val">true </span>} } } <span class="kw">pub use </span>location :: { Cluster , Process } ; <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>hydroflow_lang :: graph :: HydroflowGraph ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub mod </span>graphs { <span class="kw">pub use </span>hydroflow_lang :: graph :: HydroflowGraph ; <span class="kw">pub use super </span>:: { LocalDeploy , Node , ProcessSpec } ; <span class="kw">pub use crate </span>:: deploy :: graphs :: SingleProcessGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>SingleProcessGraph { <span class="kw">type </span>Process = SingleNode ; <span class="kw">type </span>Cluster = SingleNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = () ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { SingleNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { SingleNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, SingleProcessGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; SingleNode { SingleNode { } } } <span class="kw">pub use crate </span>:: deploy :: graphs :: SingleNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>SingleNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } <span class="kw">pub use crate </span>:: deploy :: graphs :: MultiGraph ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>MultiGraph { <span class="kw">type </span>Process = MultiNode ; <span class="kw">type </span>Cluster = MultiNode ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>GraphId = usize ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { <span class="bool-val">true </span>} <span class="kw">fn </span>trivial_process (_id : usize) -&gt; <span class="self">Self </span>:: Process { MultiNode { } } <span class="kw">fn </span>trivial_cluster (_id : usize) -&gt; <span class="self">Self </span>:: Cluster { MultiNode { } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; ProcessSpec &lt; <span class="lifetime">'a </span>, MultiGraph &gt; <span class="kw">for </span>() { <span class="kw">fn </span>build (<span class="self">self </span>, _id : usize , _name_hint : &amp; str) -&gt; MultiNode { MultiNode { } } } <span class="kw">pub use crate </span>:: deploy :: graphs :: MultiNode ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Node <span class="kw">for </span>MultiNode { <span class="kw">type </span>Port = () ; <span class="kw">type </span>Meta = () ; <span class="kw">type </span>InstantiateEnv = () ; <span class="kw">fn </span>next_port (&amp; <span class="self">self</span>) { panic ! () ; } <span class="kw">fn </span>update_meta (&amp; <span class="kw-2">mut </span><span class="self">self </span>, _meta : &amp; <span class="self">Self </span>:: Meta) { } <span class="kw">fn </span>instantiate (&amp; <span class="self">self </span>, _env : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: InstantiateEnv , _meta : &amp; <span class="kw-2">mut </span><span class="self">Self </span>:: Meta , _graph : HydroflowGraph , _extra_stmts : Vec &lt; syn :: Stmt &gt; ,) { } } } <span class="kw">pub use </span>graphs :: * ; <span class="kw">pub use crate </span>:: deploy :: LocalDeploy ; <span class="kw">pub use crate </span>:: deploy :: Deploy ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, T : Deploy &lt; <span class="lifetime">'a </span>, Process = N , Cluster = C , Meta = M , GraphId = R &gt; , N : Node &lt; Meta = M &gt; , C : Node &lt; Meta = M &gt; , M : Default , R , &gt; LocalDeploy &lt; <span class="lifetime">'a </span>&gt; <span class="kw">for </span>T { <span class="kw">type </span>Process = N ; <span class="kw">type </span>Cluster = C ; <span class="kw">type </span>Meta = M ; <span class="kw">type </span>GraphId = R ; <span class="kw">fn </span>has_trivial_node () -&gt; bool { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: has_trivial_node () } <span class="kw">fn </span>trivial_process (id : usize) -&gt; <span class="self">Self </span>:: Process { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivial_process (id) } <span class="kw">fn </span>trivial_cluster (id : usize) -&gt; <span class="self">Self </span>:: Cluster { &lt; T <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: trivail_cluster (id) } } <span class="kw">pub use crate </span>:: deploy :: ProcessSpec ; <span class="kw">pub use crate </span>:: deploy :: ClusterSpec ; <span class="kw">pub use crate </span>:: deploy :: Node ; } <span class="kw">pub use </span>deploy :: { ClusterSpec , Deploy , ProcessSpec } ; <span class="kw">pub mod </span>cycle { <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use crate </span>:: builder :: FlowLeaves ; <span class="kw">pub use crate </span>:: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: cycle :: CycleComplete ; <span class="kw">pub use crate </span>:: cycle :: CycleCollection ; <span class="kw">pub use crate </span>:: cycle :: CycleCollectionWithInitial ; <span class="kw">pub use crate </span>:: cycle :: HfCycle ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, S : CycleComplete &lt; <span class="lifetime">'a </span>&gt; &gt; HfCycle &lt; <span class="lifetime">'a </span>, S &gt; { <span class="kw">pub fn </span>complete (<span class="self">self </span>, stream : S) { <span class="kw">let </span>ident = <span class="self">self </span>. ident ; S :: complete (stream , ident) } } } <span class="kw">pub use </span>cycle :: HfCycle ; <span class="kw">pub mod </span>builder { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashMap ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>std :: time :: Duration ; <span class="kw">pub use </span>hydroflow :: futures :: stream :: Stream <span class="kw">as </span>FuturesStream ; <span class="kw">pub use </span>hydroflow :: { tokio , tokio_stream } ; <span class="kw">pub use </span>internal :: TokenStream ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>quote :: quote ; <span class="kw">pub use </span>runtime_support :: FreeVariable ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: cycle :: { CycleCollection , CycleCollectionWithInitial } ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , HfPlusSource } ; <span class="kw">pub use crate </span>:: location :: { Cluster , Location , LocationId , Process } ; <span class="kw">pub use crate </span>:: stream :: { Bounded , NoTick , Tick , Unbounded } ; <span class="kw">pub use crate </span>:: { HfCycle , Optional , RuntimeContext , Singleton , Stream } ; <span class="kw">pub mod </span>built { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>hydroflow_lang :: graph :: { eliminate_extra_unions_tees , HydroflowGraph } ; <span class="kw">pub use super </span>:: deploy :: { DeployFlow , DeployResult } ; <span class="kw">pub use crate </span>:: deploy :: { ClusterSpec , Deploy , LocalDeploy , ProcessSpec } ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { Cluster , Process } ; <span class="kw">pub use crate </span>:: HfCompiled ; <span class="kw">pub use crate </span>:: builder :: built :: BuiltFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Drop <span class="kw">for </span>BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped BuiltFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>ir (&amp; <span class="self">self</span>) -&gt; &amp; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; { &amp; <span class="self">self </span>. ir } <span class="kw">pub fn </span>optimize_with (<span class="kw-2">mut </span><span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt;) -&gt; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; ,) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; BuiltFlow { ir : f (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir)) , processes : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. processes) , clusters : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } } <span class="kw">pub fn </span>build_inner (ir : &amp; <span class="kw-2">mut </span>Vec &lt; HfPlusLeaf &gt;) -&gt; BTreeMap &lt; usize , HydroflowGraph &gt; { <span class="kw">let </span><span class="kw-2">mut </span>builders = BTreeMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>built_tees = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>next_stmt_id = <span class="number">0 </span>; <span class="kw">for </span>leaf <span class="kw">in </span>ir { leaf . emit (&amp; <span class="kw-2">mut </span>builders , &amp; <span class="kw-2">mut </span>built_tees , &amp; <span class="kw-2">mut </span>next_stmt_id) ; } builders . into_iter () . map (| (k , v) | { <span class="kw">let </span>(<span class="kw-2">mut </span>flat_graph , <span class="kw">_ </span>, <span class="kw">_</span>) = v . build () ; eliminate_extra_unions_tees (&amp; <span class="kw-2">mut </span>flat_graph) ; (k , flat_graph) }) . collect () } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>compile_no_network &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; HfCompiled { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , extra_stmts : BTreeMap :: new () , _phantom : PhantomData , } } <span class="kw">pub fn </span>with_default_optimize (<span class="self">self</span>) -&gt; BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. optimize_with (<span class="kw">crate </span>:: persist_pullup :: persist_pullup) } <span class="kw">fn </span>into_deploy &lt; D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span>processes = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. processes . iter () . map (| id | (* id , D :: trivial_process (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; <span class="kw">let </span>clusters = <span class="kw">if </span>D :: has_trivial_node () { <span class="self">self </span>. clusters . iter () . map (| id | (* id , D :: trivial_cluster (* id))) . collect () } <span class="kw">else </span>{ HashMap :: new () } ; DeployFlow { ir : std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) , nodes : processes , clusters , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_process &lt; P , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_process (process , spec) } <span class="kw">pub fn </span>with_cluster &lt; C , D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; (<span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt; ,) -&gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy () . with_cluster (cluster , spec) } <span class="kw">pub fn </span>compile &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . compile (env) } <span class="kw">pub fn </span>deploy &lt; D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv ,) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. into_deploy :: &lt; D &gt; () . deploy (env) } } } <span class="kw">pub mod </span>deploy { <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: marker :: PhantomData ; <span class="kw">pub use </span>proc_macro2 :: Span ; <span class="kw">pub use </span>stageleft :: Quoted ; <span class="kw">pub use super </span>:: built :: build_inner ; <span class="kw">pub use crate </span>:: deploy :: { LocalDeploy , Node } ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; <span class="kw">pub use crate </span>:: location :: { Location , LocationId } ; <span class="kw">pub use crate </span>:: { Cluster , ClusterSpec , Deploy , HfCompiled , Process , ProcessSpec } ; <span class="kw">pub use crate </span>:: builder :: deploy :: DeployFlow ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; Drop <span class="kw">for </span>DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. used { panic ! (<span class="string">"Dropped DeployFlow without instantiating, you may have forgotten to call `compile` or `deploy`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : LocalDeploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>with_process &lt; P &gt; (<span class="kw-2">mut </span><span class="self">self </span>, process : &amp; Process &lt; P &gt; , spec : <span class="kw">impl </span>ProcessSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; P &gt; () . to_string () ; <span class="self">self </span>. nodes . insert (process . id , spec . build (process . id , &amp; tag_name)) ; <span class="self">self </span>} <span class="kw">pub fn </span>with_cluster &lt; C &gt; (<span class="kw-2">mut </span><span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; , spec : <span class="kw">impl </span>ClusterSpec &lt; <span class="lifetime">'a </span>, D &gt;) -&gt; <span class="self">Self </span>{ <span class="kw">let </span>tag_name = std :: any :: type_name :: &lt; C &gt; () . to_string () ; <span class="self">self </span>. clusters . insert (cluster . id , spec . build (cluster . id , &amp; tag_name)) ; <span class="self">self </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>compile (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; D :: CompileEnv) -&gt; HfCompiled &lt; <span class="lifetime">'a </span>, D :: GraphId &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>ir_leaves_networked : Vec &lt; HfPlusLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | leaf . compile_network :: &lt; D &gt; (env , &amp; <span class="kw-2">mut </span>seen_tees , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters)) . collect () ; <span class="kw">let </span>extra_stmts = <span class="self">self </span>. extra_stmts (env) ; HfCompiled { hydroflow_ir : build_inner (&amp; <span class="kw-2">mut </span>ir_leaves_networked) , extra_stmts , _phantom : PhantomData , } } <span class="kw">fn </span>extra_stmts (&amp; <span class="self">self </span>, env : &amp; &lt; D <span class="kw">as </span>Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; :: CompileEnv) -&gt; BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; { <span class="kw">let </span>all_locations_count = <span class="self">self </span>. nodes . len () + <span class="self">self </span>. clusters . len () ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts : BTreeMap &lt; usize , Vec &lt; syn :: Stmt &gt; &gt; = BTreeMap :: new () ; <span class="kw">for </span>&amp; c_id <span class="kw">in </span><span class="self">self </span>. clusters . keys () { <span class="kw">let </span>self_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_self_id_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>self_id_expr = D :: cluster_self_id (env) . splice () ; extra_stmts . entry (c_id) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># self_id_ident = # self_id_expr ; }) ; <span class="kw">for </span>other_location <span class="kw">in </span><span class="number">0 </span>.. all_locations_count { <span class="kw">let </span>other_id_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_ids_{}" </span>, c_id) , Span :: call_site () ,) ; <span class="kw">let </span>other_id_expr = D :: cluster_ids (env , c_id) . splice () ; extra_stmts . entry (other_location) . or_default () . push (syn :: parse_quote ! { <span class="kw">let </span># other_id_ident = # other_id_expr ; }) ; } } extra_stmts } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>, CompileEnv = () &gt; &gt; DeployFlow &lt; <span class="lifetime">'a </span>, D &gt; { # [must_use] <span class="kw">pub fn </span>deploy (<span class="kw-2">mut </span><span class="self">self </span>, env : &amp; <span class="kw-2">mut </span>D :: InstantiateEnv) -&gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="self">self </span>. used = <span class="bool-val">true </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_instantiate : HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; = HashMap :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>ir_leaves_networked : Vec &lt; HfPlusLeaf &gt; = std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. ir) . into_iter () . map (| leaf | { leaf . compile_network :: &lt; D &gt; (&amp; () , &amp; <span class="kw-2">mut </span>seen_tees_instantiate , &amp; <span class="self">self </span>. nodes , &amp; <span class="self">self </span>. clusters ,) }) . collect () ; <span class="kw">let </span><span class="kw-2">mut </span>compiled = build_inner (&amp; <span class="kw-2">mut </span>ir_leaves_networked) ; <span class="kw">let </span><span class="kw-2">mut </span>extra_stmts = <span class="self">self </span>. extra_stmts (&amp; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>meta = D :: Meta :: default () ; <span class="kw">let </span>(<span class="kw-2">mut </span>processes , <span class="kw-2">mut </span>clusters) = (std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. nodes) . into_iter () . map (| (node_id , node) | { node . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; node_id) . unwrap () , extra_stmts . remove (&amp; node_id) . unwrap_or_default () ,) ; (node_id , node) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () , std :: mem :: take (&amp; <span class="kw-2">mut </span><span class="self">self </span>. clusters) . into_iter () . map (| (cluster_id , cluster) | { cluster . instantiate (env , &amp; <span class="kw-2">mut </span>meta , compiled . remove (&amp; cluster_id) . unwrap () , extra_stmts . remove (&amp; cluster_id) . unwrap_or_default () ,) ; (cluster_id , cluster) }) . collect :: &lt; HashMap &lt; <span class="kw">_ </span>, <span class="kw">_ </span>&gt; &gt; () ,) ; <span class="kw">for </span>node <span class="kw">in </span>processes . values_mut () { node . update_meta (&amp; meta) ; } <span class="kw">for </span>cluster <span class="kw">in </span>clusters . values_mut () { cluster . update_meta (&amp; meta) ; } <span class="kw">let </span><span class="kw-2">mut </span>seen_tees_connect = HashMap :: new () ; <span class="kw">for </span>leaf <span class="kw">in </span>ir_leaves_networked { leaf . connect_network (&amp; <span class="kw-2">mut </span>seen_tees_connect) ; } DeployResult { processes , clusters , } } } <span class="kw">pub use crate </span>:: builder :: deploy :: DeployResult ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, D : Deploy &lt; <span class="lifetime">'a </span>&gt; &gt; DeployResult &lt; <span class="lifetime">'a </span>, D &gt; { <span class="kw">pub fn </span>get_process &lt; P &gt; (&amp; <span class="self">self </span>, p : &amp; Process &lt; P &gt;) -&gt; &amp; D :: Process { <span class="kw">let </span>id = <span class="kw">match </span>p . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; <span class="self">self </span>. processes . get (&amp; id) . unwrap () } <span class="kw">pub fn </span>get_cluster &lt; C &gt; (&amp; <span class="self">self </span>, c : &amp; Cluster &lt; C &gt;) -&gt; &amp; D :: Cluster { <span class="kw">let </span>id = <span class="kw">match </span>c . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; <span class="self">self </span>. clusters . get (&amp; id) . unwrap () } } } # [doc = <span class="string">" Tracks the leaves of the dataflow IR. This is referenced by"</span>] # [doc = <span class="string">" `Stream` and `HfCycle` to build the IR. The inner option will"</span>] # [doc = <span class="string">" be set to `None` when this builder is finalized."</span>] <span class="kw">pub type </span>FlowLeaves &lt; <span class="lifetime">'a </span>&gt; = Rc &lt; RefCell &lt; <span class="prelude-ty">Option </span>&lt; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; &gt; &gt; &gt; ; <span class="kw">pub use crate </span>:: builder :: ClusterIds ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_ids_{}" </span>, <span class="self">self </span>. id) , Span :: call_site () ,) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { # ident })) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; <span class="kw">for </span>ClusterIds &lt; <span class="lifetime">'a </span>&gt; { } # [derive (Copy , Clone)] <span class="kw">pub struct </span>ClusterSelfId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub </span>id : usize , <span class="kw">pub </span>_phantom : PhantomData &lt; &amp; <span class="lifetime">'a </span><span class="kw-2">mut </span>&amp; <span class="lifetime">'a </span>u32 &gt; , } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; u32 &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) <span class="kw">where </span><span class="self">Self </span>: Sized , { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"__hydroflow_plus_cluster_self_id_{}" </span>, <span class="self">self </span>. id) , Span :: call_site () ,) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! { # ident })) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, u32 &gt; <span class="kw">for </span>ClusterSelfId &lt; <span class="lifetime">'a </span>&gt; { } <span class="kw">pub use crate </span>:: builder :: FlowBuilder ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Drop <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>drop (&amp; <span class="kw-2">mut </span><span class="self">self</span>) { <span class="kw">if </span>! <span class="self">self </span>. finalized { panic ! (<span class="string">"Dropped FlowBuilder without finalizing, you may have forgotten to call `with_default_optimize`, `optimize_with`, or `finalize`."</span>) ; } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; QuotedContext <span class="kw">for </span>FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>create () -&gt; <span class="self">Self </span>{ FlowBuilder :: new () } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { # [allow (clippy :: new_without_default)] <span class="kw">pub fn </span>new () -&gt; FlowBuilder &lt; <span class="lifetime">'a </span>&gt; { FlowBuilder { ir_leaves : Rc :: new (RefCell :: new (<span class="prelude-val">Some </span>(Vec :: new ()))) , nodes : RefCell :: new (vec ! []) , clusters : RefCell :: new (vec ! []) , cycle_ids : RefCell :: new (HashMap :: new ()) , next_node_id : RefCell :: new (<span class="number">0</span>) , finalized : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>finalize (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalized = <span class="bool-val">true </span>; built :: BuiltFlow { ir : <span class="self">self </span>. ir_leaves . borrow_mut () . take () . unwrap () , processes : <span class="self">self </span>. nodes . replace (vec ! []) , clusters : <span class="self">self </span>. clusters . replace (vec ! []) , used : <span class="bool-val">false </span>, _phantom : PhantomData , } } <span class="kw">pub fn </span>with_default_optimize (<span class="self">self</span>) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalize () . with_default_optimize () } <span class="kw">pub fn </span>optimize_with (<span class="self">self </span>, f : <span class="kw">impl </span>FnOnce (Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt;) -&gt; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; ,) -&gt; built :: BuiltFlow &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. finalize () . optimize_with (f) } <span class="kw">pub fn </span>ir_leaves (&amp; <span class="self">self</span>) -&gt; &amp; FlowLeaves &lt; <span class="lifetime">'a </span>&gt; { &amp; <span class="self">self </span>. ir_leaves } <span class="kw">pub fn </span>process &lt; P &gt; (&amp; <span class="self">self</span>) -&gt; Process &lt; P &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. nodes . borrow_mut () . push (id) ; Process { id , _phantom : PhantomData , } } <span class="kw">pub fn </span>cluster &lt; C &gt; (&amp; <span class="self">self</span>) -&gt; Cluster &lt; C &gt; { <span class="kw">let </span><span class="kw-2">mut </span>next_node_id = <span class="self">self </span>. next_node_id . borrow_mut () ; <span class="kw">let </span>id = * next_node_id ; * next_node_id += <span class="number">1 </span>; <span class="self">self </span>. clusters . borrow_mut () . push (id) ; Cluster { id , _phantom : PhantomData , } } <span class="kw">pub fn </span>runtime_context (&amp; <span class="self">self</span>) -&gt; RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { RuntimeContext { _phantom : PhantomData , } } <span class="kw">pub fn </span>cluster_members &lt; C &gt; (&amp; <span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt; ,) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, &amp; <span class="lifetime">'a </span>Vec &lt; u32 &gt; &gt; + Copy + <span class="lifetime">'a </span>{ ClusterIds { id : cluster . id , _phantom : PhantomData , } } <span class="kw">pub fn </span>cluster_self_id &lt; C &gt; (&amp; <span class="self">self </span>, cluster : &amp; Cluster &lt; C &gt;) -&gt; <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, u32 &gt; + Copy + <span class="lifetime">'a </span>{ ClusterSelfId { id : cluster . id , _phantom : PhantomData , } } <span class="kw">pub fn </span>spin &lt; L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L) -&gt; Stream &lt; <span class="lifetime">'a </span>, () , Unbounded , NoTick , L &gt; { Stream :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Spin () , location_kind : on . id () , })) ,) } <span class="kw">pub fn </span>spin_batch &lt; L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , batch_size : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Stream &lt; <span class="lifetime">'a </span>, () , Bounded , Tick , L &gt; { <span class="self">self </span>. spin (on) . flat_map (q ! (<span class="kw">move </span>| <span class="kw">_ </span>| <span class="number">0 </span>.. batch_size)) . map (q ! (| <span class="kw">_ </span>| ())) . tick_batch () } <span class="kw">pub fn </span>source_stream &lt; T , E : FuturesStream &lt; Item = T &gt; + Unpin , L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, E &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Unbounded , NoTick , L &gt; { <span class="kw">let </span>e = e . splice () ; Stream :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Stream (e . into ()) , location_kind : on . id () , })) ,) } <span class="kw">pub fn </span>source_iter &lt; T , E : IntoIterator &lt; Item = T &gt; , L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, E &gt; ,) -&gt; Stream &lt; <span class="lifetime">'a </span>, T , Bounded , NoTick , L &gt; { <span class="kw">let </span>e = e . splice () ; Stream :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Iter (e . into ()) , location_kind : on . id () , })) ,) } <span class="kw">pub fn </span>singleton &lt; T : Clone , L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, T &gt; ,) -&gt; Singleton &lt; <span class="lifetime">'a </span>, T , Bounded , NoTick , L &gt; { <span class="kw">let </span>e_arr = q ! ([e]) ; <span class="kw">let </span>e = e_arr . splice () ; Singleton :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Persist (Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Iter (e . into ()) , location_kind : on . id () , } ,)))) ,) } <span class="kw">pub fn </span>singleton_first_tick &lt; T : Clone , L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , e : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, T &gt; ,) -&gt; Optional &lt; <span class="lifetime">'a </span>, T , Bounded , Tick , L &gt; { <span class="kw">let </span>e_arr = q ! ([e]) ; <span class="kw">let </span>e = e_arr . splice () ; Optional :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Source { source : HfPlusSource :: Iter (e . into ()) , location_kind : on . id () , } ,) } <span class="kw">pub fn </span>source_interval &lt; L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , interval : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Optional &lt; <span class="lifetime">'a </span>, () , Unbounded , NoTick , L &gt; { <span class="kw">let </span>interval = interval . splice () ; Optional :: new (on . id () , <span class="self">self </span>. ir_leaves () . clone () , HfPlusNode :: Persist (Box :: new (HfPlusNode :: Source { source : HfPlusSource :: Interval (interval . into ()) , location_kind : on . id () , })) ,) } <span class="kw">pub fn </span>source_interval_delayed &lt; L : Location &gt; (&amp; <span class="self">self </span>, on : &amp; L , delay : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Duration &gt; + Copy + <span class="lifetime">'a </span>, interval : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, Duration &gt; + Copy + <span class="lifetime">'a </span>,) -&gt; Optional &lt; <span class="lifetime">'a </span>, tokio :: time :: Instant , Unbounded , NoTick , L &gt; { <span class="self">self </span>. source_stream (on , q ! (tokio_stream :: wrappers :: IntervalStream :: new (tokio :: time :: interval_at (tokio :: time :: Instant :: now () + delay , interval))) ,) . tick_batch () . first () . latest () } <span class="kw">pub fn </span>cycle &lt; S : CycleCollection &lt; <span class="lifetime">'a </span>&gt; &gt; (&amp; <span class="self">self </span>, on : &amp; S :: Location) -&gt; (HfCycle &lt; <span class="lifetime">'a </span>, S &gt; , S) { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span>on . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; <span class="kw">let </span><span class="kw-2">mut </span>cycle_ids = <span class="self">self </span>. cycle_ids . borrow_mut () ; <span class="kw">let </span>next_id_entry = cycle_ids . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (HfCycle { ident : ident . clone () , _phantom : PhantomData , } , S :: create_source (ident , <span class="self">self </span>. ir_leaves . clone () , on . id ()) ,) } <span class="kw">pub fn </span>cycle_with_initial &lt; S : CycleCollectionWithInitial &lt; <span class="lifetime">'a </span>&gt; &gt; (&amp; <span class="self">self </span>, on : &amp; S :: Location , initial : S ,) -&gt; (HfCycle &lt; <span class="lifetime">'a </span>, S &gt; , S) { <span class="kw">let </span>next_id = { <span class="kw">let </span>on_id = <span class="kw">match </span>on . id () { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; <span class="kw">let </span><span class="kw-2">mut </span>cycle_ids = <span class="self">self </span>. cycle_ids . borrow_mut () ; <span class="kw">let </span>next_id_entry = cycle_ids . entry (on_id) . or_default () ; <span class="kw">let </span>id = * next_id_entry ; * next_id_entry += <span class="number">1 </span>; id } ; <span class="kw">let </span>ident = syn :: Ident :: new (&amp; format ! (<span class="string">"cycle_{}" </span>, next_id) , Span :: call_site ()) ; (HfCycle { ident : ident . clone () , _phantom : PhantomData , } , S :: create_source (ident , <span class="self">self </span>. ir_leaves . clone () , initial , on . id ()) ,) } } } <span class="kw">pub use </span>builder :: FlowBuilder ; <span class="kw">pub mod </span>ir { <span class="kw">pub use </span>core :: panic ; <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: { BTreeMap , HashMap } ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use </span>std :: rc :: Rc ; <span class="kw">pub use </span>hydroflow_lang :: graph :: FlatGraphBuilder ; <span class="kw">pub use </span>hydroflow_lang :: parse :: Pipeline ; <span class="kw">pub use </span>proc_macro2 :: { Span , TokenStream } ; <span class="kw">pub use </span>quote :: ToTokens ; <span class="kw">pub use </span>syn :: parse_quote ; <span class="kw">pub use crate </span>:: deploy :: Deploy ; <span class="kw">pub use crate </span>:: location :: LocationId ; <span class="kw">pub use crate </span>:: ir :: DebugExpr ; # [cfg (stageleft_macro)] <span class="kw">impl </span>From &lt; syn :: Expr &gt; <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>from (expr : syn :: Expr) -&gt; DebugExpr { DebugExpr (expr) } } # [cfg (stageleft_macro)] <span class="kw">impl </span>Deref <span class="kw">for </span>DebugExpr { <span class="kw">type </span>Target = syn :: Expr ; <span class="kw">fn </span>deref (&amp; <span class="self">self</span>) -&gt; &amp; <span class="self">Self </span>:: Target { &amp; <span class="self">self </span>. <span class="number">0 </span>} } # [cfg (stageleft_macro)] <span class="kw">impl </span>ToTokens <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>to_tokens (&amp; <span class="self">self </span>, tokens : &amp; <span class="kw-2">mut </span>TokenStream) { <span class="self">self </span>. <span class="number">0 </span>. to_tokens (tokens) ; } } # [cfg (stageleft_macro)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugExpr { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"{}" </span>, <span class="self">self </span>. <span class="number">0 </span>. to_token_stream ()) } } <span class="kw">pub use crate </span>:: ir :: DebugInstantiate ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; std :: fmt :: Debug <span class="kw">for </span>DebugInstantiate &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;network instantiate&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: DebugPipelineFn ; # [cfg (stageleft_macro)] <span class="kw">impl </span>std :: fmt :: Debug <span class="kw">for </span>DebugPipelineFn { <span class="kw">fn </span>fmt (&amp; <span class="self">self </span>, f : &amp; <span class="kw-2">mut </span>std :: fmt :: Formatter &lt; <span class="lifetime">'_ </span>&gt;) -&gt; std :: fmt :: <span class="prelude-ty">Result </span>{ write ! (f , <span class="string">"&lt;function&gt;"</span>) } } <span class="kw">pub use crate </span>:: ir :: HfPlusSource ; <span class="kw">pub use crate </span>:: ir :: HfPlusLeaf ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>compile_network &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (<span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; ,) -&gt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. transform_children (| n , s | { n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters) ; } , seen_tees ,) } <span class="kw">pub fn </span>connect_network (<span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt;) -&gt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; { <span class="self">self </span>. transform_children (| n , s | { n . connect_network (s) ; } , seen_tees ,) } <span class="kw">pub fn </span>transform_children (<span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HfPlusNode &lt; <span class="lifetime">'a </span>&gt; , &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt;) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; ,) -&gt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: ForEach { f , input } } HfPlusLeaf :: DestSink { sink , <span class="kw-2">mut </span>input } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: DestSink { sink , input } } HfPlusLeaf :: CycleSink { ident , location_kind , <span class="kw-2">mut </span>input , } =&gt; { transform (&amp; <span class="kw-2">mut </span>input , seen_tees) ; HfPlusLeaf :: CycleSink { ident , location_kind , input , } } } } <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusLeaf :: ForEach { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; for_each (# f) ; }) ; } HfPlusLeaf :: DestSink { sink , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; graph_builders . entry (input_location_id) . or_default () . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink) ; }) ; } HfPlusLeaf :: CycleSink { ident , location_kind , input , } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; assert_eq ! (input_location_id , * location_id , <span class="string">"cycle_sink location mismatch"</span>) ; graph_builders . entry (* location_id) . or_default () . add_statement (parse_quote ! { # ident = # input_ident ; }) ; } } } } <span class="kw">pub use crate </span>:: ir :: HfPlusNode ; <span class="kw">pub type </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; = HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt; , Rc &lt; RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt; &gt; &gt; ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">pub fn </span>compile_network &lt; D : Deploy &lt; <span class="lifetime">'a </span>&gt; + <span class="lifetime">'a </span>&gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, compile_env : &amp; D :: CompileEnv , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; , nodes : &amp; HashMap &lt; usize , D :: Process &gt; , clusters : &amp; HashMap &lt; usize , D :: Cluster &gt; ,) { <span class="self">self </span>. transform_children (| n , s | n . compile_network :: &lt; D &gt; (compile_env , s , nodes , clusters) , seen_tees ,) ; <span class="kw">if let </span>HfPlusNode :: Network { from_location , to_location , instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">let </span>(sink_expr , source_expr , connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; { <span class="kw">let </span>((sink , source) , connect_fn) = <span class="kw">match </span>(from_location , to_location) { (LocationId :: Process (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: o2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port ,) , Box :: new (<span class="kw">move </span>| | { D :: o2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) }) <span class="kw">as </span>Box &lt; <span class="kw">dyn </span>Fn () + <span class="lifetime">'a </span>&gt; ,) } (LocationId :: Process (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = nodes . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_process_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: o2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port ,) , Box :: new (<span class="kw">move </span>| | { D :: o2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) }) <span class="kw">as </span>Box &lt; <span class="kw">dyn </span>Fn () + <span class="lifetime">'a </span>&gt; ,) } (LocationId :: Cluster (from) , LocationId :: Process (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = nodes . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_process_port (&amp; to_node) ; (D :: m2o_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port ,) , Box :: new (<span class="kw">move </span>| | { D :: m2o_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) }) <span class="kw">as </span>Box &lt; <span class="kw">dyn </span>Fn () + <span class="lifetime">'a </span>&gt; ,) } (LocationId :: Cluster (from) , LocationId :: Cluster (to)) =&gt; { <span class="kw">let </span>from_node = clusters . get (from) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, from) }) . clone () ; <span class="kw">let </span>to_node = clusters . get (to) . unwrap_or_else (| | { panic ! (<span class="string">"A location used in the graph was not instantiated: {}" </span>, to) }) . clone () ; <span class="kw">let </span>sink_port = D :: allocate_cluster_port (&amp; from_node) ; <span class="kw">let </span>source_port = D :: allocate_cluster_port (&amp; to_node) ; (D :: m2m_sink_source (compile_env , &amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port ,) , Box :: new (<span class="kw">move </span>| | { D :: m2m_connect (&amp; from_node , &amp; sink_port , &amp; to_node , &amp; source_port) }) <span class="kw">as </span>Box &lt; <span class="kw">dyn </span>Fn () + <span class="lifetime">'a </span>&gt; ,) } } ; (sink , source , connect_fn) } DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw">_</span>) =&gt; panic ! (<span class="string">"network already finalized"</span>) , } ; * instantiate_fn = DebugInstantiate :: Finalized (sink_expr , source_expr , connect_fn) ; } } <span class="kw">pub fn </span>connect_network (&amp; <span class="kw-2">mut </span><span class="self">self </span>, seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt;) { <span class="self">self </span>. transform_children (| n , s | n . connect_network (s) , seen_tees) ; <span class="kw">if let </span>HfPlusNode :: Network { instantiate_fn , .. } = <span class="self">self </span>{ <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; panic ! (<span class="string">"network not built"</span>) , DebugInstantiate :: Finalized (<span class="kw">_ </span>, <span class="kw">_ </span>, <span class="kw-2">ref </span>connect_fn) =&gt; { connect_fn () ; } } } } <span class="kw">pub fn </span>transform_children (&amp; <span class="kw-2">mut </span><span class="self">self </span>, <span class="kw-2">mut </span>transform : <span class="kw">impl </span>FnMut (&amp; <span class="kw-2">mut </span>HfPlusNode &lt; <span class="lifetime">'a </span>&gt; , &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt;) , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; ,) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () ; } HfPlusNode :: Source { .. } =&gt; { } HfPlusNode :: CycleSource { .. } =&gt; { } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(transformed) = seen_tees . get (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { * inner = transformed . clone () ; } <span class="kw">else </span>{ <span class="kw">let </span>transformed_cell = Rc :: new (RefCell :: new (HfPlusNode :: Placeholder)) ; seen_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , transformed_cell . clone () ,) ; <span class="kw">let </span><span class="kw-2">mut </span>orig = inner . replace (HfPlusNode :: Placeholder) ; transform (&amp; <span class="kw-2">mut </span>orig , seen_tees) ; * transformed_cell . borrow_mut () = orig ; * inner = transformed_cell ; } } HfPlusNode :: Persist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Unpersist (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Delta (inner) =&gt; transform (inner . as_mut () , seen_tees) , HfPlusNode :: Union (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: CrossProduct (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: CrossSingleton (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Join (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Difference (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: AntiJoin (left , right) =&gt; { transform (left . as_mut () , seen_tees) ; transform (right . as_mut () , seen_tees) ; } HfPlusNode :: Map { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FlatMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Filter { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FilterMap { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Sort (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: DeferTick (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Enumerate (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Inspect { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Unique (input) =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Fold { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: FoldKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Reduce { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: ReduceKeyed { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } HfPlusNode :: Network { input , .. } =&gt; { transform (input . as_mut () , seen_tees) ; } } } <span class="kw">pub fn </span>emit (&amp; <span class="self">self </span>, graph_builders : &amp; <span class="kw-2">mut </span>BTreeMap &lt; usize , FlatGraphBuilder &gt; , built_tees : &amp; <span class="kw-2">mut </span>HashMap &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt; , (syn :: Ident , usize) &gt; , next_stmt_id : &amp; <span class="kw-2">mut </span>usize ,) -&gt; (syn :: Ident , usize) { <span class="kw">match </span><span class="self">self </span>{ HfPlusNode :: Placeholder =&gt; { panic ! () } HfPlusNode :: Persist (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>persist_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>persist_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, persist_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # persist_ident = # inner_ident -&gt; persist ::&lt;<span class="lifetime">'static </span>&gt; () ; }) ; (persist_ident , location) } HfPlusNode :: Unpersist (<span class="kw">_</span>) =&gt; { panic ! (<span class="string">"Unpersist is a marker node and should have been optimized away. This is likely a compiler bug."</span>) } HfPlusNode :: Delta (inner) =&gt; { <span class="kw">let </span>(inner_ident , location) = inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>delta_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>delta_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, delta_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (location) . or_default () ; builder . add_statement (parse_quote ! { # delta_ident = # inner_ident -&gt; multiset_delta () ; }) ; (delta_ident , location) } HfPlusNode :: Source { source , location_kind , } =&gt; { <span class="kw">let </span>source_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>source_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, source_id) , Span :: call_site ()) ; <span class="kw">let </span>source_stmt = <span class="kw">match </span>source { HfPlusSource :: Stream (expr) =&gt; { parse_quote ! { # source_ident = source_stream (# expr) ; } } HfPlusSource :: Iter (expr) =&gt; { parse_quote ! { # source_ident = source_iter (# expr) ; } } HfPlusSource :: Interval (expr) =&gt; { parse_quote ! { # source_ident = source_interval (# expr) ; } } HfPlusSource :: Spin () =&gt; { parse_quote ! { # source_ident = spin () ; } } } ; <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; graph_builders . entry (* location_id) . or_default () . add_statement (source_stmt) ; (source_ident , * location_id) } HfPlusNode :: CycleSource { ident , location_kind , } =&gt; { <span class="kw">let </span>location_id = <span class="kw">match </span>location_kind { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; (ident . clone () , * location_id) } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if let </span><span class="prelude-val">Some </span>(ret) = built_tees . get (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt;)) { ret . clone () } <span class="kw">else </span>{ <span class="kw">let </span>(inner_ident , inner_location_id) = inner . borrow () . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>tee_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>tee_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, tee_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (inner_location_id) . or_default () ; builder . add_statement (parse_quote ! { # tee_ident = # inner_ident -&gt; tee () ; }) ; built_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &gt; , (tee_ident . clone () , inner_location_id) ,) ; (tee_ident , inner_location_id) } } HfPlusNode :: Union (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"union inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>union_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # union_ident = union () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # union_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # union_ident ; }) ; (union_ident , left_location_id) } HfPlusNode :: CrossSingleton (left , right) =&gt; { <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"cross_singleton inputs must be in the same location"</span>) ; <span class="kw">let </span>union_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>cross_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, union_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; builder . add_statement (parse_quote ! { # cross_ident = cross_singleton () ; }) ; builder . add_statement (parse_quote ! { # left_ident -&gt; [input] # cross_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [single] # cross_ident ; }) ; (cross_ident , left_location_id) } HfPlusNode :: CrossProduct (..) | HfPlusNode :: Join (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: CrossProduct (..)) { parse_quote ! (cross_join_multiset) } <span class="kw">else </span>{ parse_quote ! (join_multiset) } ; <span class="kw">let </span>(HfPlusNode :: CrossProduct (left , right) | HfPlusNode :: Join (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(left_inner , left_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (left) = left . as_ref () { (left , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (left , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(right_inner , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left_inner . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right_inner . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"join / cross product inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">match </span>(left_was_persist , right_was_persist) { (<span class="bool-val">true </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">true </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'static </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">true</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } (<span class="bool-val">false </span>, <span class="bool-val">false</span>) =&gt; { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } } ; builder . add_statement (parse_quote ! { # left_ident -&gt; [<span class="number">0</span>] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [<span class="number">1</span>] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Difference (..) | HfPlusNode :: AntiJoin (..) =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Difference (..)) { parse_quote ! (difference_multiset) } <span class="kw">else </span>{ parse_quote ! (anti_join_multiset) } ; <span class="kw">let </span>(HfPlusNode :: Difference (left , right) | HfPlusNode :: AntiJoin (left , right)) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(right , right_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (right) = right . as_ref () { (right , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (right , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(left_ident , left_location_id) = left . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>(right_ident , right_location_id) = right . emit (graph_builders , built_tees , next_stmt_id) ; assert_eq ! (left_location_id , right_location_id , <span class="string">"difference / anti join inputs must be in the same location"</span>) ; <span class="kw">let </span>stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, stream_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (left_location_id) . or_default () ; <span class="kw">if </span>right_was_persist { builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'static </span>&gt; () ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # stream_ident = # operator ::&lt;<span class="lifetime">'tick </span>, <span class="lifetime">'tick </span>&gt; () ; }) ; } builder . add_statement (parse_quote ! { # left_ident -&gt; [pos] # stream_ident ; }) ; builder . add_statement (parse_quote ! { # right_ident -&gt; [neg] # stream_ident ; }) ; (stream_ident , left_location_id) } HfPlusNode :: Map { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # map_ident = # input_ident -&gt; map (# f) ; }) ; (map_ident , input_location_id) } HfPlusNode :: FlatMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>flat_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>flat_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, flat_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # flat_map_ident = # input_ident -&gt; flat_map (# f) ; }) ; (flat_map_ident , input_location_id) } HfPlusNode :: Filter { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_ident = # input_ident -&gt; filter (# f) ; }) ; (filter_ident , input_location_id) } HfPlusNode :: FilterMap { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>filter_map_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>filter_map_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, filter_map_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # filter_map_ident = # input_ident -&gt; filter_map (# f) ; }) ; (filter_map_ident , input_location_id) } HfPlusNode :: Sort (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sort_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>sort_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, sort_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # sort_ident = # input_ident -&gt; sort () ; }) ; (sort_ident , input_location_id) } HfPlusNode :: DeferTick (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>defer_tick_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>defer_tick_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, defer_tick_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # defer_tick_ident = # input_ident -&gt; defer_tick_lazy () ; }) ; (defer_tick_ident , input_location_id) } HfPlusNode :: Enumerate (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>enumerate_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>enumerate_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, enumerate_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # enumerate_ident = # input_ident -&gt; enumerate () ; }) ; (enumerate_ident , input_location_id) } HfPlusNode :: Inspect { f , input } =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>inspect_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>inspect_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, inspect_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # inspect_ident = # input_ident -&gt; inspect (# f) ; }) ; (inspect_ident , input_location_id) } HfPlusNode :: Unique (input) =&gt; { <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>unique_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>unique_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, unique_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; builder . add_statement (parse_quote ! { # unique_ident = # input_ident -&gt; unique ::&lt;<span class="lifetime">'tick </span>&gt; () ; }) ; (unique_ident , input_location_id) } HfPlusNode :: Fold { .. } | HfPlusNode :: FoldKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Fold { .. }) { parse_quote ! (fold) } <span class="kw">else </span>{ parse_quote ! (fold_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Fold { init , acc , input } | HfPlusNode :: FoldKeyed { init , acc , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>fold_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# init , # acc) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # fold_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# init , # acc) ; }) ; } (fold_ident , input_location_id) } HfPlusNode :: Reduce { .. } | HfPlusNode :: ReduceKeyed { .. } =&gt; { <span class="kw">let </span>operator : syn :: Ident = <span class="kw">if </span>matches ! (<span class="self">self </span>, HfPlusNode :: Reduce { .. }) { parse_quote ! (reduce) } <span class="kw">else </span>{ parse_quote ! (reduce_keyed) } ; <span class="kw">let </span>(HfPlusNode :: Reduce { f , input } | HfPlusNode :: ReduceKeyed { f , input }) = <span class="self">self </span><span class="kw">else </span>{ unreachable ! () } ; <span class="kw">let </span>(input , input_was_persist) = <span class="kw">if let </span>HfPlusNode :: Persist (input) = input . as_ref () { (input , <span class="bool-val">true</span>) } <span class="kw">else </span>{ (input , <span class="bool-val">false</span>) } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>reduce_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>reduce_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, reduce_id) , Span :: call_site ()) ; <span class="kw">let </span>builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if </span>input_was_persist { builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'static </span>&gt; (# f) ; }) ; } <span class="kw">else </span>{ builder . add_statement (parse_quote ! { # reduce_ident = # input_ident -&gt; # operator ::&lt;<span class="lifetime">'tick </span>&gt; (# f) ; }) ; } (reduce_ident , input_location_id) } HfPlusNode :: Network { from_location : <span class="kw">_ </span>, to_location , serialize_pipeline , instantiate_fn , deserialize_pipeline , input , } =&gt; { <span class="kw">let </span>(sink_expr , source_expr , _connect_fn) = <span class="kw">match </span>instantiate_fn { DebugInstantiate :: Building () =&gt; { panic ! (<span class="string">"Expected the network to be finalized"</span>) } DebugInstantiate :: Finalized (sink , source , connect_fn) =&gt; { (sink , source , connect_fn) } } ; <span class="kw">let </span>(input_ident , input_location_id) = input . emit (graph_builders , built_tees , next_stmt_id) ; <span class="kw">let </span>sender_builder = graph_builders . entry (input_location_id) . or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(serialize_pipeline) = serialize_pipeline { sender_builder . add_statement (parse_quote ! { # input_ident -&gt; # serialize_pipeline -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">else </span>{ sender_builder . add_statement (parse_quote ! { # input_ident -&gt; dest_sink (# sink_expr) ; }) ; } <span class="kw">let </span>to_id = <span class="kw">match </span>to_location { LocationId :: Process (id) =&gt; id , LocationId :: Cluster (id) =&gt; id , } ; <span class="kw">let </span>receiver_builder = graph_builders . entry (* to_id) . or_default () ; <span class="kw">let </span>receiver_stream_id = * next_stmt_id ; * next_stmt_id += <span class="number">1 </span>; <span class="kw">let </span>receiver_stream_ident = syn :: Ident :: new (&amp; format ! (<span class="string">"stream_{}" </span>, receiver_stream_id) , Span :: call_site ()) ; <span class="kw">if let </span><span class="prelude-val">Some </span>(deserialize_pipeline) = deserialize_pipeline { receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) -&gt; # deserialize_pipeline ; }) ; } <span class="kw">else </span>{ receiver_builder . add_statement (parse_quote ! { # receiver_stream_ident = source_stream (# source_expr) ; }) ; } (receiver_stream_ident , * to_id) } } } } } <span class="kw">pub mod </span>persist_pullup { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use </span>std :: ops :: Deref ; <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub fn </span>persist_pullup_node &lt; <span class="lifetime">'a </span>&gt; (node : &amp; <span class="kw-2">mut </span>HfPlusNode &lt; <span class="lifetime">'a </span>&gt; , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; , persist_pulled_tees : &amp; <span class="kw-2">mut </span>HashSet &lt; * <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt; &gt; ,) { node . transform_children (| n , s | persist_pullup_node (n , s , persist_pulled_tees) , seen_tees ,) ; <span class="kw">match </span>node { HfPlusNode :: Unpersist (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>)) =&gt; { <span class="kw">if let </span>HfPlusNode :: Unpersist (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist)) = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = behind_persist ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Delta (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>)) =&gt; { <span class="kw">if let </span>HfPlusNode :: Delta (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist)) = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = behind_persist ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Tee { inner } =&gt; { <span class="kw">if </span>persist_pulled_tees . contains (&amp; (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt;)) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Tee { inner : inner . clone () , })) ; } <span class="kw">else </span>{ <span class="kw">let </span>inner_borrow = inner . borrow () ; <span class="kw">if let </span>HfPlusNode :: Persist (<span class="kw">_</span>) = inner_borrow . deref () { drop (inner_borrow) ; persist_pulled_tees . insert (inner . as_ref () <span class="kw">as </span>* <span class="kw">const </span>RefCell &lt; HfPlusNode &lt; <span class="lifetime">'a </span>&gt; &gt;) ; <span class="kw">if let </span>HfPlusNode :: Persist (<span class="kw">box </span>behind_persist) = inner . replace (HfPlusNode :: Placeholder) { * inner . borrow_mut () = behind_persist ; } <span class="kw">else </span>{ unreachable ! () } * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Tee { inner : inner . clone () , })) ; } } } HfPlusNode :: Map { f : <span class="kw">_ </span>, input : <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , } =&gt; { <span class="kw">if let </span>HfPlusNode :: Map { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Map { f , input : behind_persist , })) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: FlatMap { f : <span class="kw">_ </span>, input : <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , } =&gt; { <span class="kw">if let </span>HfPlusNode :: FlatMap { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: FlatMap { f , input : behind_persist , })) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Filter { f : <span class="kw">_ </span>, input : <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , } =&gt; { <span class="kw">if let </span>HfPlusNode :: Filter { f , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Filter { f , input : behind_persist , })) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Network { input : <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , .. } =&gt; { <span class="kw">if let </span>HfPlusNode :: Network { from_location , to_location , serialize_pipeline , instantiate_fn , deserialize_pipeline , input : <span class="kw">box </span>HfPlusNode :: Persist (behind_persist) , } = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Network { from_location , to_location , serialize_pipeline , instantiate_fn , deserialize_pipeline , input : behind_persist , })) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Union (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>)) =&gt; { <span class="kw">if let </span>HfPlusNode :: Union (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right) ,) = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Union (left , right))) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: CrossProduct (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>)) =&gt; { <span class="kw">if let </span>HfPlusNode :: CrossProduct (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right) ,) = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Delta (Box :: new (HfPlusNode :: CrossProduct (Box :: new (HfPlusNode :: Persist (left)) , Box :: new (HfPlusNode :: Persist (right)) ,) ,)))) ; } <span class="kw">else </span>{ unreachable ! () } } HfPlusNode :: Join (<span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>) , <span class="kw">box </span>HfPlusNode :: Persist (<span class="kw">_</span>)) =&gt; { <span class="kw">if let </span>HfPlusNode :: Join (<span class="kw">box </span>HfPlusNode :: Persist (left) , <span class="kw">box </span>HfPlusNode :: Persist (right)) = std :: mem :: replace (node , HfPlusNode :: Placeholder) { * node = HfPlusNode :: Persist (Box :: new (HfPlusNode :: Delta (Box :: new (HfPlusNode :: Join (Box :: new (HfPlusNode :: Persist (left)) , Box :: new (HfPlusNode :: Persist (right)) ,))))) ; } <span class="kw">else </span>{ unreachable ! () } } <span class="kw">_ </span>=&gt; { } } } <span class="kw">pub fn </span>persist_pullup (ir : Vec &lt; HfPlusLeaf &gt;) -&gt; Vec &lt; HfPlusLeaf &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; <span class="kw">let </span><span class="kw-2">mut </span>persist_pulled_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| n , s | persist_pullup_node (n , s , &amp; <span class="kw-2">mut </span>persist_pulled_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: * ; <span class="kw">use crate </span>:: deploy :: MultiGraph ; # [test] <span class="kw">fn </span>persist_pullup_through_map () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } # [test] <span class="kw">fn </span>persist_pullup_behind_tee () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>before_tee = flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . tick_batch () . persist () ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; before_tee . clone () . map (q ! (| v | v + <span class="number">1</span>)) . all_ticks () . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let </span>optimized = built . optimize_with (<span class="kw">super </span>:: persist_pullup) ; insta :: assert_debug_snapshot ! (optimized . ir ()) ; <span class="kw">for </span>(id , graph) <span class="kw">in </span>optimized . compile_no_network :: &lt; MultiGraph &gt; () . hydroflow_ir () { insta :: with_settings ! ({ snapshot_suffix =&gt; format ! (<span class="string">"surface_graph_{id}"</span>) } , { insta :: assert_snapshot ! (graph . surface_syntax_string ()) ; }) ; } } } } <span class="kw">pub mod </span>profiler { <span class="kw">pub use </span>std :: cell :: RefCell ; <span class="kw">pub use </span>hydroflow :: futures :: channel :: mpsc :: UnboundedSender ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate as </span>hydroflow_plus ; <span class="kw">pub use crate </span>:: ir :: * ; <span class="kw">pub use crate </span>:: RuntimeContext ; <span class="kw">pub fn </span>increment_counter (count : &amp; <span class="kw-2">mut </span>u64) { * count += <span class="number">1 </span>; } <span class="kw">pub fn </span>quoted_any_fn &lt; <span class="lifetime">'a </span>, F : Fn (&amp; usize) + <span class="lifetime">'a </span>, Q : IntoQuotedMut &lt; <span class="lifetime">'a </span>, F &gt; &gt; (q : Q) -&gt; Q { q } # [doc = <span class="string">" Add a profiling node before each node to count the cardinality of its input"</span>] <span class="kw">pub fn </span>add_profiling_node &lt; <span class="lifetime">'a </span>&gt; (node : &amp; <span class="kw-2">mut </span>HfPlusNode &lt; <span class="lifetime">'a </span>&gt; , _context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; , id : &amp; <span class="kw-2">mut </span>u32 , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; ,) { <span class="kw">let </span>my_id = * id ; * id += <span class="number">1 </span>; node . transform_children (| node , seen_tees | { add_profiling_node (node , _context , counters , counter_queue , id , seen_tees) } , seen_tees ,) ; <span class="kw">let </span>orig_node = std :: mem :: replace (node , HfPlusNode :: Placeholder) ; * node = HfPlusNode :: Inspect { f : quoted_any_fn (q ! ({ counter_queue . borrow () . unbounded_send ((my_id <span class="kw">as </span>usize , counters . borrow () [my_id <span class="kw">as </span>usize])) . unwrap () ; counters . borrow_mut () [my_id <span class="kw">as </span>usize] = <span class="number">0 </span>; <span class="kw">move </span>| <span class="kw">_ </span>| { hydroflow_plus :: profiler :: increment_counter (&amp; <span class="kw-2">mut </span>counters . borrow_mut () [my_id <span class="kw">as </span>usize] ,) ; } })) . splice () . into () , input : Box :: new (orig_node) , } } # [doc = <span class="string">" Count the cardinality of each input and periodically output to a file"</span>] <span class="kw">pub fn </span>profiling &lt; <span class="lifetime">'a </span>&gt; (ir : Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; , context : RuntimeContext &lt; <span class="lifetime">'a </span>&gt; , counters : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; Vec &lt; u64 &gt; &gt; &gt; , counter_queue : RuntimeData &lt; &amp; <span class="lifetime">'a </span>RefCell &lt; UnboundedSender &lt; (usize , u64) &gt; &gt; &gt; ,) -&gt; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span><span class="kw-2">mut </span>id = <span class="number">0 </span>; <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | { add_profiling_node (node , context , counters , counter_queue , &amp; <span class="kw-2">mut </span>id , seen_tees) } , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use </span>stageleft :: * ; <span class="kw">use crate </span>:: deploy :: MultiGraph ; # [test] <span class="kw">fn </span>profiler_wrapping_all_operators () { <span class="kw">let </span>flow = <span class="kw">crate </span>:: builder :: FlowBuilder :: new () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; flow . source_iter (&amp; process , q ! (<span class="number">0 </span>.. <span class="number">10</span>)) . map (q ! (| v | v + <span class="number">1</span>)) . for_each (q ! (| n | println ! (<span class="string">"{}" </span>, n))) ; <span class="kw">let </span>runtime_context = flow . runtime_context () ; <span class="kw">let </span>built = flow . finalize () ; insta :: assert_debug_snapshot ! (&amp; built . ir ()) ; <span class="kw">let </span>counters = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>counter_queue = RuntimeData :: new (<span class="string">"Fake"</span>) ; <span class="kw">let </span>pushed_down = built . with_default_optimize () . optimize_with (| ir | <span class="kw">super </span>:: profiling (ir , runtime_context , counters , counter_queue)) ; insta :: assert_debug_snapshot ! (&amp; pushed_down . ir ()) ; <span class="kw">let _ </span>= pushed_down . compile_no_network :: &lt; MultiGraph &gt; () ; } } } <span class="kw">pub mod </span>properties { <span class="kw">pub use </span>std :: collections :: HashSet ; <span class="kw">pub use </span>stageleft :: * ; <span class="kw">pub use crate </span>:: ir :: { HfPlusLeaf , HfPlusNode , SeenTees } ; <span class="kw">pub use crate </span>:: properties :: PropertyDatabase ; # [doc = <span class="string">" Allows us to convert the hydroflow datatype for folds to a binary operation for the algebra"</span>] # [doc = <span class="string">" property tests."</span>] # [allow (dead_code)] <span class="kw">pub fn </span>convert_hf_to_binary &lt; I , A : Default , F : Fn (&amp; <span class="kw-2">mut </span>A , I) &gt; (f : F) -&gt; <span class="kw">impl </span>Fn (I , I) -&gt; A { <span class="kw">move </span>| a , b | { <span class="kw">let </span><span class="kw-2">mut </span>acc = Default :: default () ; f (&amp; <span class="kw-2">mut </span>acc , a) ; f (&amp; <span class="kw-2">mut </span>acc , b) ; acc } } # [cfg (stageleft_macro)] <span class="kw">impl </span>PropertyDatabase { # [doc = <span class="string">" Tags the expression as commutative."</span>] <span class="kw">pub fn </span>add_commutative_tag &lt; <span class="lifetime">'a </span>, I , A , F : Fn (&amp; <span class="kw-2">mut </span>A , I) , Q : Quoted &lt; <span class="lifetime">'a </span>, F &gt; + Clone &gt; (&amp; <span class="kw-2">mut </span><span class="self">self </span>, expr : Q ,) -&gt; Q { <span class="kw">let </span>expr_clone = expr . clone () ; <span class="self">self </span>. commutative . insert (expr_clone . splice ()) ; expr } <span class="kw">pub fn </span>is_tagged_commutative (&amp; <span class="self">self </span>, expr : &amp; syn :: Expr) -&gt; bool { <span class="self">self </span>. commutative . contains (expr) } } <span class="kw">pub fn </span>properties_optimize_node &lt; <span class="lifetime">'a </span>&gt; (node : &amp; <span class="kw-2">mut </span>HfPlusNode &lt; <span class="lifetime">'a </span>&gt; , db : &amp; PropertyDatabase , seen_tees : &amp; <span class="kw-2">mut </span>SeenTees &lt; <span class="lifetime">'a </span>&gt; ,) { node . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , seen_tees ,) ; <span class="kw">match </span>node { HfPlusNode :: ReduceKeyed { f , .. } <span class="kw">if </span>db . is_tagged_commutative (&amp; f . <span class="number">0</span>) =&gt; { dbg ! (<span class="string">"IDENTIFIED COMMUTATIVE OPTIMIZATION for {:?}" </span>, &amp; f) ; } <span class="kw">_ </span>=&gt; { } } } <span class="kw">pub fn </span>properties_optimize &lt; <span class="lifetime">'a </span>&gt; (ir : Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; , db : &amp; PropertyDatabase ,) -&gt; Vec &lt; HfPlusLeaf &lt; <span class="lifetime">'a </span>&gt; &gt; { <span class="kw">let </span><span class="kw-2">mut </span>seen_tees = Default :: default () ; ir . into_iter () . map (| l | { l . transform_children (| node , seen_tees | properties_optimize_node (node , db , seen_tees) , &amp; <span class="kw-2">mut </span>seen_tees ,) }) . collect () } # [cfg (stageleft_macro)] # [cfg (test)] <span class="kw">mod </span>tests { <span class="kw">use super </span>:: * ; <span class="kw">use crate </span>:: deploy :: SingleProcessGraph ; <span class="kw">use crate </span>:: FlowBuilder ; # [test] <span class="kw">fn </span>test_property_database () { <span class="kw">let </span><span class="kw-2">mut </span>db = PropertyDatabase :: default () ; assert ! (! db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice ()))) ; <span class="kw">let _ </span>= db . add_commutative_tag (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b)) ; assert ! (db . is_tagged_commutative (&amp; (q ! (| a : &amp; <span class="kw-2">mut </span>i32 , b : i32 | * a += b) . splice ()))) ; } # [test] <span class="kw">fn </span>test_property_optimized () { <span class="kw">let </span>flow = FlowBuilder :: new () ; <span class="kw">let </span><span class="kw-2">mut </span>database = PropertyDatabase :: default () ; <span class="kw">let </span>process = flow . process :: &lt; () &gt; () ; <span class="kw">let </span>counter_func = q ! (| count : &amp; <span class="kw-2">mut </span>i32 , <span class="kw">_ </span>| * count += <span class="number">1</span>) ; <span class="kw">let _ </span>= database . add_commutative_tag (counter_func) ; flow . source_iter (&amp; process , q ! (vec ! [])) . map (q ! (| string : String | (string , ()))) . tick_batch () . fold_keyed (q ! (|| <span class="number">0</span>) , counter_func) . all_ticks () . for_each (q ! (| (string , count) | println ! (<span class="string">"{}: {}" </span>, string , count))) ; <span class="kw">let </span>built = flow . finalize () . optimize_with (| ir | properties_optimize (ir , &amp; database)) . with_default_optimize () ; insta :: assert_debug_snapshot ! (built . ir ()) ; <span class="kw">let _ </span>= built . compile_no_network :: &lt; SingleProcessGraph &gt; () ; } } } <span class="kw">pub use crate </span>:: RuntimeContext ; # [cfg (stageleft_macro)] <span class="kw">impl </span>Copy <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'_ </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; &amp; <span class="lifetime">'a </span>Context &gt; <span class="kw">for </span>RuntimeContext &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(quote ! (&amp; context))) } } <span class="kw">pub use crate </span>:: HfCompiled ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>, ID &gt; HfCompiled &lt; <span class="lifetime">'a </span>, ID &gt; { <span class="kw">pub fn </span>hydroflow_ir (&amp; <span class="self">self</span>) -&gt; &amp; BTreeMap &lt; usize , HydroflowGraph &gt; { &amp; <span class="self">self </span>. hydroflow_ir } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; HfCompiled &lt; <span class="lifetime">'a </span>, usize &gt; { <span class="kw">pub fn </span>with_dynamic_id (<span class="self">self </span>, id : <span class="kw">impl </span>Quoted &lt; <span class="lifetime">'a </span>, usize &gt;) -&gt; HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">let </span><span class="kw-2">mut </span>conditioned_tokens = <span class="prelude-val">None </span>; <span class="kw">for </span>(subgraph_id , flat_graph) <span class="kw">in </span><span class="self">self </span>. hydroflow_ir { <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; <span class="kw">let </span>my_extra_stmts = <span class="self">self </span>. extra_stmts . get (&amp; subgraph_id) . cloned () . unwrap_or_default () ; <span class="kw">if let </span><span class="prelude-val">Some </span>(conditioned_tokens) = conditioned_tokens . as_mut () { * conditioned_tokens = syn :: parse_quote ! { # conditioned_tokens <span class="kw">else if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } } ; } <span class="kw">else </span>{ conditioned_tokens = <span class="prelude-val">Some </span>(syn :: parse_quote ! { <span class="kw">if </span>__given_id == # subgraph_id { # (# my_extra_stmts) * # tokens } }) ; } } <span class="kw">let </span>conditioned_tokens : TokenStream = conditioned_tokens . unwrap () ; <span class="kw">let </span>id = id . splice () ; HfBuiltWithId { tokens : syn :: parse_quote ! ({ <span class="kw">let </span>__given_id = # id ; # conditioned_tokens <span class="kw">else </span>{ panic ! (<span class="string">"Invalid node id: {}" </span>, __given_id) ; } }) , _phantom : PhantomData , } } } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfCompiled &lt; <span class="lifetime">'a </span>, () &gt; { <span class="kw">fn </span>to_tokens (<span class="kw-2">mut </span><span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { <span class="kw">let </span>hydroflow_crate = proc_macro_crate :: crate_name (<span class="string">"hydroflow_plus"</span>) . expect (<span class="string">"hydroflow_plus should be present in `Cargo.toml`"</span>) ; <span class="kw">let </span>root = <span class="kw">match </span>hydroflow_crate { proc_macro_crate :: FoundCrate :: Itself =&gt; quote ! { hydroflow_plus } , proc_macro_crate :: FoundCrate :: Name (name) =&gt; { <span class="kw">let </span>ident = syn :: Ident :: new (&amp; name , proc_macro2 :: Span :: call_site ()) ; quote ! { # ident } } } ; <span class="kw">if </span><span class="self">self </span>. hydroflow_ir . len () != <span class="number">1 </span>{ panic ! (<span class="string">"Expected exactly one subgraph in the Hydroflow IR"</span>) ; } <span class="kw">let </span>flat_graph = <span class="self">self </span>. hydroflow_ir . remove (&amp; <span class="number">0</span>) . unwrap () ; <span class="kw">let </span>partitioned_graph = partition_graph (flat_graph) . expect (<span class="string">"Failed to partition (cycle detected)."</span>) ; <span class="kw">let </span><span class="kw-2">mut </span>diagnostics = Vec :: new () ; <span class="kw">let </span>tokens = partitioned_graph . as_code (&amp; root , <span class="bool-val">true </span>, quote :: quote ! () , &amp; <span class="kw-2">mut </span>diagnostics) ; (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(tokens)) } } <span class="kw">pub use crate </span>:: HfBuiltWithId ; # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; Quoted &lt; <span class="lifetime">'a </span>, Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { } # [cfg (stageleft_macro)] <span class="kw">impl </span>&lt; <span class="lifetime">'a </span>&gt; FreeVariable &lt; Hydroflow &lt; <span class="lifetime">'a </span>&gt; &gt; <span class="kw">for </span>HfBuiltWithId &lt; <span class="lifetime">'a </span>&gt; { <span class="kw">fn </span>to_tokens (<span class="self">self</span>) -&gt; (<span class="prelude-ty">Option </span>&lt; TokenStream &gt; , <span class="prelude-ty">Option </span>&lt; TokenStream &gt;) { (<span class="prelude-val">None </span>, <span class="prelude-val">Some </span>(<span class="self">self </span>. tokens)) } }</code></pre></div></section></main></body></html>